import 'dart:convert';
import 'dart:math';
import 'package:flutter/material.dart';
import 'package:shared_preferences/shared_preferences.dart';
import '../models/health_data.dart';
import 'storage_service.dart';
import 'daily_tracking_service.dart';
import 'ai_service.dart';

/// Service AI Chatbot th√¥ng minh
class AIChatbotService extends ChangeNotifier {
  static final AIChatbotService _instance = AIChatbotService._internal();
  factory AIChatbotService() => _instance;
  AIChatbotService._internal();

  static const String _conversationKey = 'ai_conversation_history';
  static const String _chatSettingsKey = 'ai_chat_settings';

  List<ChatMessage> _conversationHistory = [];
  ChatSettings _settings = ChatSettings();
  bool _isInitialized = false;

  List<ChatMessage> get conversationHistory => _conversationHistory;
  ChatSettings get settings => _settings;
  bool get isInitialized => _isInitialized;

  /// Kh·ªüi t·∫°o service
  Future<void> initialize() async {
    if (_isInitialized) return;
    
    await _loadSettings();
    await _loadConversationHistory();
    _isInitialized = true;
    notifyListeners();
  }

  /// T·∫£i c√†i ƒë·∫∑t chat
  Future<void> _loadSettings() async {
    final prefs = await SharedPreferences.getInstance();
    final settingsString = prefs.getString(_chatSettingsKey);
    
    if (settingsString != null) {
      try {
        final settingsMap = jsonDecode(settingsString) as Map<String, dynamic>;
        _settings = ChatSettings.fromMap(settingsMap);
      } catch (e) {
        _settings = ChatSettings();
      }
    }
  }

  /// L∆∞u c√†i ƒë·∫∑t chat
  Future<void> saveSettings(ChatSettings settings) async {
    _settings = settings;
    final prefs = await SharedPreferences.getInstance();
    await prefs.setString(_chatSettingsKey, jsonEncode(settings.toMap()));
    notifyListeners();
  }

  /// T·∫£i l·ªãch s·ª≠ h·ªôi tho·∫°i
  Future<void> _loadConversationHistory() async {
    final prefs = await SharedPreferences.getInstance();
    final historyString = prefs.getString(_conversationKey) ?? '[]';
    
    try {
      final List<dynamic> historyList = jsonDecode(historyString);
      _conversationHistory = historyList
          .map((json) => ChatMessage.fromMap(json as Map<String, dynamic>))
          .toList();
    } catch (e) {
      _conversationHistory = [];
    }

    // Th√™m tin nh·∫Øn ch√†o m·ª´ng n·∫øu ch∆∞a c√≥
    if (_conversationHistory.isEmpty) {
      _addWelcomeMessage();
    }
  }

  /// L∆∞u l·ªãch s·ª≠ h·ªôi tho·∫°i
  Future<void> _saveConversationHistory() async {
    final prefs = await SharedPreferences.getInstance();
    final historyJson = _conversationHistory.map((msg) => msg.toMap()).toList();
    await prefs.setString(_conversationKey, jsonEncode(historyJson));
  }

  /// Th√™m tin nh·∫Øn ch√†o m·ª´ng
  void _addWelcomeMessage() {
    final welcomeMessage = ChatMessage(
      id: _generateMessageId(),
      text: "Xin ch√†o! T√¥i l√† AI Health Assistant c·ªßa b·∫°n. ü§ñ\n\n"
            "T√¥i c√≥ th·ªÉ gi√∫p b·∫°n:\n"
            "‚Ä¢ Ph√¢n t√≠ch d·ªØ li·ªáu s·ª©c kh·ªèe\n"
            "‚Ä¢ ƒê∆∞a ra l·ªùi khuy√™n c√° nh√¢n h√≥a\n"
            "‚Ä¢ Tr·∫£ l·ªùi c√¢u h·ªèi v·ªÅ dinh d∆∞·ª°ng\n"
            "‚Ä¢ T·∫°o k·∫ø ho·∫°ch t·∫≠p luy·ªán\n"
            "‚Ä¢ Theo d√µi ti·∫øn ƒë·ªô c·ªßa b·∫°n\n\n"
            "H√£y h·ªèi t√¥i b·∫•t c·ª© ƒëi·ªÅu g√¨! üòä",
      isUser: false,
      timestamp: DateTime.now(),
      messageType: MessageType.welcome,
    );
    
    _conversationHistory.add(welcomeMessage);
  }

  /// G·ª≠i tin nh·∫Øn v√† nh·∫≠n ph·∫£n h·ªìi
  Future<ChatMessage> sendMessage(String userMessage) async {
    // Th√™m tin nh·∫Øn c·ªßa user
    final userChatMessage = ChatMessage(
      id: _generateMessageId(),
      text: userMessage,
      isUser: true,
      timestamp: DateTime.now(),
      messageType: MessageType.text,
    );
    
    _conversationHistory.add(userChatMessage);
    await _saveConversationHistory();
    notifyListeners();

    // Simulate typing delay
    await Future.delayed(Duration(milliseconds: 500 + Random().nextInt(1500)));

    // T·∫°o ph·∫£n h·ªìi AI
    final aiResponse = await _generateAIResponse(userMessage);
    
    _conversationHistory.add(aiResponse);
    await _saveConversationHistory();
    notifyListeners();

    return aiResponse;
  }

  /// T·∫°o ph·∫£n h·ªìi AI
  Future<ChatMessage> _generateAIResponse(String userMessage) async {
    final lowerMessage = userMessage.toLowerCase();
    
    // Ph√¢n lo·∫°i intent
    final intent = _classifyIntent(lowerMessage);
    
    String responseText;
    MessageType messageType = MessageType.text;
    Map<String, dynamic>? actionData;

    switch (intent) {
      case ChatIntent.healthAnalysis:
        responseText = await _generateHealthAnalysisResponse();
        messageType = MessageType.healthAnalysis;
        break;
      
      case ChatIntent.nutritionAdvice:
        responseText = _generateNutritionAdvice(lowerMessage);
        messageType = MessageType.advice;
        break;
      
      case ChatIntent.exerciseAdvice:
        responseText = _generateExerciseAdvice(lowerMessage);
        messageType = MessageType.advice;
        break;
      
      case ChatIntent.goalSetting:
        responseText = await _generateGoalSettingResponse();
        messageType = MessageType.goalSetting;
        break;
      
      case ChatIntent.motivational:
        responseText = _generateMotivationalResponse();
        messageType = MessageType.motivational;
        break;
      
      case ChatIntent.dataQuery:
        responseText = await _generateDataQueryResponse(lowerMessage);
        messageType = MessageType.dataQuery;
        break;
      
      case ChatIntent.general:
        responseText = await _generateGeneralResponse(lowerMessage);
        break;
    }

    return ChatMessage(
      id: _generateMessageId(),
      text: responseText,
      isUser: false,
      timestamp: DateTime.now(),
      messageType: messageType,
      actionData: actionData,
    );
  }

  /// Ph√¢n lo·∫°i intent c·ªßa tin nh·∫Øn
  ChatIntent _classifyIntent(String message) {
    // Health analysis keywords
    if (message.contains('ph√¢n t√≠ch') || message.contains('ƒë√°nh gi√°') || 
        message.contains('t√¨nh tr·∫°ng') || message.contains('s·ª©c kh·ªèe c·ªßa t√¥i')) {
      return ChatIntent.healthAnalysis;
    }

    // Nutrition keywords
    if (message.contains('ƒÉn') || message.contains('th·ª©c ƒÉn') || 
        message.contains('dinh d∆∞·ª°ng') || message.contains('calories') ||
        message.contains('th·ª±c ƒë∆°n') || message.contains('m√≥n ƒÉn')) {
      return ChatIntent.nutritionAdvice;
    }

    // Exercise keywords
    if (message.contains('t·∫≠p') || message.contains('th·ªÉ d·ª•c') || 
        message.contains('v·∫≠n ƒë·ªông') || message.contains('gym') ||
        message.contains('cardio') || message.contains('yoga')) {
      return ChatIntent.exerciseAdvice;
    }

    // Goal setting keywords
    if (message.contains('m·ª•c ti√™u') || message.contains('k·∫ø ho·∫°ch') || 
        message.contains('gi·∫£m c√¢n') || message.contains('tƒÉng c√¢n') ||
        message.contains('c·∫£i thi·ªán')) {
      return ChatIntent.goalSetting;
    }

    // Motivational keywords
    if (message.contains('ƒë·ªông vi√™n') || message.contains('khuy·∫øn kh√≠ch') || 
        message.contains('c·∫£m th·∫•y') || message.contains('bu·ªìn') ||
        message.contains('stress') || message.contains('m·ªát m·ªèi')) {
      return ChatIntent.motivational;
    }

    // Data query keywords
    if (message.contains('bao nhi√™u') || message.contains('th·ªëng k√™') || 
        message.contains('s·ªë li·ªáu') || message.contains('d·ªØ li·ªáu') ||
        message.contains('ti·∫øn ƒë·ªô') || message.contains('k·∫øt qu·∫£')) {
      return ChatIntent.dataQuery;
    }

    return ChatIntent.general;
  }

  /// T·∫°o ph·∫£n h·ªìi ph√¢n t√≠ch s·ª©c kh·ªèe
  Future<String> _generateHealthAnalysisResponse() async {
    final latestData = await StorageService.getLatestData();
    final trackingService = DailyTrackingService();
    await trackingService.initialize();
    final todayRecord = trackingService.getTodayRecord();

    if (latestData == null) {
      return "T√¥i ch∆∞a th·∫•y d·ªØ li·ªáu s·ª©c kh·ªèe c·ªßa b·∫°n. H√£y nh·∫≠p th√¥ng tin c∆° b·∫£n nh∆∞ chi·ªÅu cao, c√¢n n·∫∑ng ƒë·ªÉ t√¥i c√≥ th·ªÉ ph√¢n t√≠ch nh√©! üìä";
    }

    final bmi = latestData.bmi;
    final steps = todayRecord.steps;
    final water = todayRecord.waterIntake;

    String analysis = "üìä **Ph√¢n t√≠ch s·ª©c kh·ªèe hi·ªán t·∫°i:**\n\n";
    
    // BMI analysis
    if (bmi < 18.5) {
      analysis += "‚Ä¢ BMI: ${bmi.toStringAsFixed(1)} - H∆°i th·∫•p, n√™n tƒÉng c√¢n l√†nh m·∫°nh\n";
    } else if (bmi < 25) {
      analysis += "‚Ä¢ BMI: ${bmi.toStringAsFixed(1)} - Tuy·ªát v·ªùi! Trong m·ª©c b√¨nh th∆∞·ªùng\n";
    } else if (bmi < 30) {
      analysis += "‚Ä¢ BMI: ${bmi.toStringAsFixed(1)} - H∆°i cao, n√™n gi·∫£m c√¢n nh·∫π\n";
    } else {
      analysis += "‚Ä¢ BMI: ${bmi.toStringAsFixed(1)} - C·∫ßn gi·∫£m c√¢n ƒë·ªÉ c·∫£i thi·ªán s·ª©c kh·ªèe\n";
    }

    // Activity analysis
    if (steps >= 10000) {
      analysis += "‚Ä¢ Ho·∫°t ƒë·ªông: Xu·∫•t s·∫Øc! $steps b∆∞·ªõc h√¥m nay üö∂‚Äç‚ôÇÔ∏è\n";
    } else if (steps >= 5000) {
      analysis += "‚Ä¢ Ho·∫°t ƒë·ªông: T·ªët! $steps b∆∞·ªõc, c·ªë g·∫Øng th√™m nh√© üí™\n";
    } else {
      analysis += "‚Ä¢ Ho·∫°t ƒë·ªông: C·∫ßn c·∫£i thi·ªán, ch·ªâ $steps b∆∞·ªõc h√¥m nay üèÉ‚Äç‚ôÇÔ∏è\n";
    }

    // Water analysis
    if (water >= 2.0) {
      analysis += "‚Ä¢ N∆∞·ªõc u·ªëng: Tuy·ªát v·ªùi! ${water.toStringAsFixed(1)}L h√¥m nay üíß\n";
    } else {
      analysis += "‚Ä¢ N∆∞·ªõc u·ªëng: C·∫ßn u·ªëng th√™m, m·ªõi ${water.toStringAsFixed(1)}L ü•§\n";
    }

    analysis += "\nB·∫°n c√≥ mu·ªën t√¥i ƒë∆∞a ra g·ª£i √Ω c·∫£i thi·ªán kh√¥ng? ü§î";

    return analysis;
  }

  /// T·∫°o l·ªùi khuy√™n dinh d∆∞·ª°ng
  String _generateNutritionAdvice(String message) {
    final nutritionTips = [
      "ü•ó **L·ªùi khuy√™n dinh d∆∞·ª°ng:**\n\n‚Ä¢ ƒÇn nhi·ªÅu rau xanh v√† tr√°i c√¢y\n‚Ä¢ Ch·ªçn protein n·∫°c nh∆∞ c√°, g√†, ƒë·∫≠u\n‚Ä¢ H·∫°n ch·∫ø ƒë∆∞·ªùng v√† th·ª±c ph·∫©m ch·∫ø bi·∫øn\n‚Ä¢ U·ªëng ƒë·ªß n∆∞·ªõc m·ªói ng√†y",
      "üçé **Th·ª±c ƒë∆°n l√†nh m·∫°nh:**\n\n‚Ä¢ S√°ng: Y·∫øn m·∫°ch + tr√°i c√¢y + s·ªØa\n‚Ä¢ Tr∆∞a: C∆°m g·∫°o l·ª©t + th·ªãt/c√° + rau\n‚Ä¢ T·ªëi: Salad + protein + √≠t carbs\n‚Ä¢ Snack: H·∫°t, s·ªØa chua, tr√°i c√¢y",
      "‚öñÔ∏è **C√¢n b·∫±ng dinh d∆∞·ª°ng:**\n\n‚Ä¢ 50% rau c·ªß qu·∫£\n‚Ä¢ 25% protein\n‚Ä¢ 25% carbs ph·ª©c h·ª£p\n‚Ä¢ Healthy fats t·ª´ avocado, nuts",
    ];

    if (message.contains('gi·∫£m c√¢n')) {
      return "üéØ **Dinh d∆∞·ª°ng gi·∫£m c√¢n:**\n\n‚Ä¢ T·∫°o deficit 300-500 calories/ng√†y\n‚Ä¢ TƒÉng protein l√™n 1.6-2.2g/kg\n‚Ä¢ ƒÇn nhi·ªÅu ch·∫•t x∆° ƒë·ªÉ no l√¢u\n‚Ä¢ U·ªëng n∆∞·ªõc tr∆∞·ªõc b·ªØa ƒÉn\n‚Ä¢ ƒÇn ch·∫≠m v√† nhai k·ªπ";
    }

    if (message.contains('tƒÉng c√¢n')) {
      return "üí™ **Dinh d∆∞·ª°ng tƒÉng c√¢n:**\n\n‚Ä¢ Th·∫∑ng d∆∞ 300-500 calories/ng√†y\n‚Ä¢ ƒÇn nhi·ªÅu b·ªØa nh·ªè (5-6 b·ªØa)\n‚Ä¢ T·∫≠p trung v√†o healthy fats\n‚Ä¢ Protein shake sau t·∫≠p\n‚Ä¢ Th√™m nuts, avocado v√†o m√≥n ƒÉn";
    }

    return nutritionTips[Random().nextInt(nutritionTips.length)];
  }

  /// T·∫°o l·ªùi khuy√™n t·∫≠p luy·ªán
  String _generateExerciseAdvice(String message) {
    final exerciseTips = [
      "üèÉ‚Äç‚ôÇÔ∏è **K·∫ø ho·∫°ch t·∫≠p luy·ªán:**\n\n‚Ä¢ 150 ph√∫t cardio/tu·∫ßn\n‚Ä¢ 2-3 ng√†y t·∫≠p t·∫°\n‚Ä¢ Yoga/stretching 2 ng√†y\n‚Ä¢ Ngh·ªâ ng∆°i 1-2 ng√†y",
      "üí™ **B√†i t·∫≠p c∆° b·∫£n:**\n\n‚Ä¢ Squat: 3 sets x 15 reps\n‚Ä¢ Push-up: 3 sets x 10 reps\n‚Ä¢ Plank: 3 sets x 30s\n‚Ä¢ Burpee: 3 sets x 8 reps",
      "üßò‚Äç‚ôÄÔ∏è **T·∫≠p nh·∫π nh√†ng:**\n\n‚Ä¢ ƒêi b·ªô 30 ph√∫t\n‚Ä¢ Yoga 20 ph√∫t\n‚Ä¢ Stretching 15 ph√∫t\n‚Ä¢ Thi·ªÅn 10 ph√∫t",
    ];

    if (message.contains('gi·∫£m c√¢n')) {
      return "üî• **T·∫≠p luy·ªán gi·∫£m c√¢n:**\n\n‚Ä¢ HIIT 3 ng√†y/tu·∫ßn (20-30 ph√∫t)\n‚Ä¢ Cardio 2 ng√†y/tu·∫ßn (45 ph√∫t)\n‚Ä¢ T·∫≠p t·∫° 2 ng√†y/tu·∫ßn\n‚Ä¢ ƒêi b·ªô h√†ng ng√†y\n‚Ä¢ TƒÉng c∆∞·ªùng ƒë·ªô d·∫ßn d·∫ßn";
    }

    if (message.contains('tƒÉng c∆°')) {
      return "üí™ **T·∫≠p luy·ªán tƒÉng c∆°:**\n\n‚Ä¢ T·∫≠p t·∫° 4-5 ng√†y/tu·∫ßn\n‚Ä¢ Compound exercises ∆∞u ti√™n\n‚Ä¢ Progressive overload\n‚Ä¢ Ngh·ªâ ng∆°i ƒë·∫ßy ƒë·ªß\n‚Ä¢ Cardio nh·∫π 2 ng√†y/tu·∫ßn";
    }

    return exerciseTips[Random().nextInt(exerciseTips.length)];
  }

  /// T·∫°o ph·∫£n h·ªìi v·ªÅ m·ª•c ti√™u
  Future<String> _generateGoalSettingResponse() async {
    return "üéØ **ƒê·∫∑t m·ª•c ti√™u th√¥ng minh:**\n\n"
           "H√£y cho t√¥i bi·∫øt:\n"
           "‚Ä¢ B·∫°n mu·ªën ƒë·∫°t ƒë∆∞·ª£c g√¨?\n"
           "‚Ä¢ Trong bao l√¢u?\n"
           "‚Ä¢ T·∫°i sao m·ª•c ti√™u n√†y quan tr·ªçng?\n\n"
           "T√¥i s·∫Ω gi√∫p b·∫°n t·∫°o k·∫ø ho·∫°ch chi ti·∫øt! üìã";
  }

  /// T·∫°o ph·∫£n h·ªìi ƒë·ªông vi√™n
  String _generateMotivationalResponse() {
    final motivationalMessages = [
      "üí™ B·∫°n ƒëang l√†m r·∫•t t·ªët! M·ªói b∆∞·ªõc nh·ªè ƒë·ªÅu quan tr·ªçng tr√™n h√†nh tr√¨nh s·ª©c kh·ªèe.",
      "üåü H√£y nh·ªõ r·∫±ng: Ti·∫øn b·ªô kh√¥ng ph·∫£i l√∫c n√†o c≈©ng ho√†n h·∫£o, nh∆∞ng ki√™n tr√¨ s·∫Ω ƒë∆∞a b·∫°n ƒë·∫øn ƒë√≠ch!",
      "üéØ Th√†nh c√¥ng kh√¥ng ƒë·∫øn t·ª´ vi·ªác kh√¥ng bao gi·ªù th·∫•t b·∫°i, m√† t·ª´ vi·ªác kh√¥ng bao gi·ªù b·ªè cu·ªôc!",
      "üöÄ C∆° th·ªÉ b·∫°n c√≥ th·ªÉ l√†m ƒë∆∞·ª£c. Ch·ªâ c·∫ßn thuy·∫øt ph·ª•c t√¢m tr√≠ th√¥i!",
      "‚≠ê M·ªói ng√†y l√† m·ªôt c∆° h·ªôi m·ªõi ƒë·ªÉ tr·ªü th√†nh phi√™n b·∫£n t·ªët h∆°n c·ªßa ch√≠nh m√¨nh!",
    ];

    return motivationalMessages[Random().nextInt(motivationalMessages.length)];
  }

  /// T·∫°o ph·∫£n h·ªìi truy v·∫•n d·ªØ li·ªáu
  Future<String> _generateDataQueryResponse(String message) async {
    final trackingService = DailyTrackingService();
    await trackingService.initialize();
    final weeklyStats = trackingService.getWeeklyStats();

    return "üìà **Th·ªëng k√™ tu·∫ßn n√†y:**\n\n"
           "‚Ä¢ B∆∞·ªõc ch√¢n TB: ${weeklyStats['averageSteps']} b∆∞·ªõc/ng√†y\n"
           "‚Ä¢ T·ªïng n∆∞·ªõc u·ªëng: ${weeklyStats['totalWater'].toStringAsFixed(1)}L\n"
           "‚Ä¢ Gi·∫•c ng·ªß TB: ${weeklyStats['averageSleep'].toStringAsFixed(1)} gi·ªù/ƒë√™m\n"
           "‚Ä¢ S·ªë ng√†y theo d√µi: ${weeklyStats['daysTracked']}/7\n\n"
           "B·∫°n mu·ªën xem th·ªëng k√™ n√†o kh√°c kh√¥ng? ü§î";
  }

  /// T·∫°o ph·∫£n h·ªìi chung b·∫±ng AI API
  Future<String> _generateGeneralResponse(String message) async {
    try {
      // Th·ª≠ s·ª≠ d·ª•ng AI API th·ª±c t·∫ø
      final aiService = AIService();
      final aiResponse = await aiService.askHealthQuestion(message);

      // N·∫øu c√≥ response t·ª´ AI, s·ª≠ d·ª•ng n√≥
      if (aiResponse.isNotEmpty && !aiResponse.contains('API key')) {
        return aiResponse;
      }
    } catch (e) {
      // N·∫øu AI API kh√¥ng kh·∫£ d·ª•ng, s·ª≠ d·ª•ng fallback responses
      print('AI API kh√¥ng kh·∫£ d·ª•ng: $e');
    }

    // Fallback responses khi AI API kh√¥ng ho·∫°t ƒë·ªông
    final generalResponses = [
      "T√¥i hi·ªÉu b·∫°n ƒëang quan t√¢m ƒë·∫øn s·ª©c kh·ªèe! B·∫°n c√≥ th·ªÉ h·ªèi t√¥i v·ªÅ dinh d∆∞·ª°ng, t·∫≠p luy·ªán, ho·∫∑c ph√¢n t√≠ch d·ªØ li·ªáu s·ª©c kh·ªèe. üòä",
      "ƒê√≥ l√† m·ªôt c√¢u h·ªèi hay! T√¥i c√≥ th·ªÉ gi√∫p b·∫°n v·ªõi c√°c v·∫•n ƒë·ªÅ v·ªÅ s·ª©c kh·ªèe, dinh d∆∞·ª°ng v√† t·∫≠p luy·ªán. B·∫°n mu·ªën bi·∫øt g√¨ c·ª• th·ªÉ? ü§î",
      "C·∫£m ∆°n b·∫°n ƒë√£ chia s·∫ª! T√¥i lu√¥n s·∫µn s√†ng h·ªó tr·ª£ b·∫°n tr√™n h√†nh tr√¨nh s·ª©c kh·ªèe. C√≥ ƒëi·ªÅu g√¨ t√¥i c√≥ th·ªÉ gi√∫p kh√¥ng? üí™",
      "T√¥i ƒëang h·ªçc h·ªèi ƒë·ªÉ tr·∫£ l·ªùi t·ªët h∆°n! Hi·ªán t·∫°i b·∫°n c√≥ th·ªÉ h·ªèi v·ªÅ BMI, dinh d∆∞·ª°ng, t·∫≠p luy·ªán ho·∫∑c gi·∫•c ng·ªß. ü§ñ",
    ];

    return generalResponses[Random().nextInt(generalResponses.length)];
  }

  /// T·∫°o ID tin nh·∫Øn
  String _generateMessageId() {
    return DateTime.now().millisecondsSinceEpoch.toString();
  }

  /// X√≥a l·ªãch s·ª≠ h·ªôi tho·∫°i
  Future<void> clearConversationHistory() async {
    _conversationHistory.clear();
    _addWelcomeMessage();
    await _saveConversationHistory();
    notifyListeners();
  }

  /// L·∫•y g·ª£i √Ω c√¢u h·ªèi
  List<String> getQuestionSuggestions() {
    return [
      "Ph√¢n t√≠ch s·ª©c kh·ªèe c·ªßa t√¥i",
      "T·∫°o th·ª±c ƒë∆°n gi·∫£m c√¢n",
      "K·∫ø ho·∫°ch t·∫≠p luy·ªán cho ng∆∞·ªùi m·ªõi",
      "T√¥i n√™n u·ªëng bao nhi√™u n∆∞·ªõc?",
      "C√°ch c·∫£i thi·ªán gi·∫•c ng·ªß",
      "Th·ªëng k√™ tu·∫ßn n√†y c·ªßa t√¥i",
    ];
  }
}

// Enums v√† Models
enum ChatIntent {
  healthAnalysis,
  nutritionAdvice,
  exerciseAdvice,
  goalSetting,
  motivational,
  dataQuery,
  general,
}

enum MessageType {
  text,
  welcome,
  healthAnalysis,
  advice,
  goalSetting,
  motivational,
  dataQuery,
}

class ChatMessage {
  final String id;
  final String text;
  final bool isUser;
  final DateTime timestamp;
  final MessageType messageType;
  final Map<String, dynamic>? actionData;

  ChatMessage({
    required this.id,
    required this.text,
    required this.isUser,
    required this.timestamp,
    this.messageType = MessageType.text,
    this.actionData,
  });

  Map<String, dynamic> toMap() {
    return {
      'id': id,
      'text': text,
      'isUser': isUser,
      'timestamp': timestamp.millisecondsSinceEpoch,
      'messageType': messageType.index,
      'actionData': actionData,
    };
  }

  factory ChatMessage.fromMap(Map<String, dynamic> map) {
    return ChatMessage(
      id: map['id'] ?? '',
      text: map['text'] ?? '',
      isUser: map['isUser'] ?? false,
      timestamp: DateTime.fromMillisecondsSinceEpoch(map['timestamp'] ?? 0),
      messageType: MessageType.values[map['messageType'] ?? 0],
      actionData: map['actionData'],
    );
  }
}

class ChatSettings {
  final bool enableNotifications;
  final bool enableSuggestions;
  final bool saveHistory;
  final String language;

  ChatSettings({
    this.enableNotifications = true,
    this.enableSuggestions = true,
    this.saveHistory = true,
    this.language = 'vi',
  });

  ChatSettings copyWith({
    bool? enableNotifications,
    bool? enableSuggestions,
    bool? saveHistory,
    String? language,
  }) {
    return ChatSettings(
      enableNotifications: enableNotifications ?? this.enableNotifications,
      enableSuggestions: enableSuggestions ?? this.enableSuggestions,
      saveHistory: saveHistory ?? this.saveHistory,
      language: language ?? this.language,
    );
  }

  Map<String, dynamic> toMap() {
    return {
      'enableNotifications': enableNotifications,
      'enableSuggestions': enableSuggestions,
      'saveHistory': saveHistory,
      'language': language,
    };
  }

  factory ChatSettings.fromMap(Map<String, dynamic> map) {
    return ChatSettings(
      enableNotifications: map['enableNotifications'] ?? true,
      enableSuggestions: map['enableSuggestions'] ?? true,
      saveHistory: map['saveHistory'] ?? true,
      language: map['language'] ?? 'vi',
    );
  }
}
